     1                                  ;数据串传送 原始位置是DS:SI 目标位置是ES:DI
     2                                  ;传送方向：
     3                                      ;正向传送：原始地址和目标地址都是从低地址到高地址推进
     4                                      ;反向传送：原始地址和目标地址都是从高地址到低地址推送
     5                                  ;在bochs虚拟机中查看标志寄存器信息: info eflags\rflags\flags
     6                                      ;显示的是各个标志寄存器的名字,大写表示值为1,小写表示值为0
     7                                  ;在8086处理器上,如果要使用寄存器来提供偏移地址,只能使用BX,SI,DI,BP,不能使用其它寄存器
     8                                  ;在8086处理器上,只允许以下集中基址变址的组合:
     9                                      ;bx+si bx+di bp+si bp+di
    10 00000000 EB10                        jmp start
    11                                  
    12 00000002 790775076E076E0769-     text db 'y',0x07, 'u',0x07, 'n',0x07, 'n',0x07, 'i',0x07
    12 0000000B 07                 
    13 0000000C 620762076407                db 'b',0x07, 'b',0x07, 'd',0x07
    14                                  
    15                                  start:
    16 00000012 B8C007                      mov ax,0x7c0 ;设置数据段基地址
    17                                                  ;为什么是7c0不是7c00,因为这里是设置的段,具体地址是段*e+偏移地址
    18 00000015 8ED8                        mov ds,ax
    19                                  
    20 00000017 B800B8                      mov ax,0xb800 ;设置附加段基地址
    21 0000001A 8EC0                        mov es,ax
    22                                  
    23 0000001C FC                          cld ;清0方向位,表示为正向传送
    24                                          ;std为置1方向位,表示为反向传送
    25 0000001D BE[0200]                    mov si,text
    26 00000020 BF0000                      mov di,0
    27                                  
    28 00000023 B90800                      mov cx,(start-text)/2 ;数据的长度的一半(一半数据，一半数据格式)
    29 00000026 F3A5                        rep movsw ;字传送指令 req代表重复执行,重复的次数由cx内的值来决定
    30                                      
    31 00000028 B8[5300]                    mov ax,number
    32                                      ;分解各个数位
    33 0000002B 89C3                        mov bx,ax
    34 0000002D B90500                      mov cx,5 ;循环次数
    35 00000030 BE0A00                      mov si,10 ;除数
    36                                  
    37                                  digist:
    38 00000033 31D2                        xor dx,dx
    39 00000035 F7F6                        div si
    40 00000037 8817                        mov [bx],dl ;保存数位
    41 00000039 43                          inc bx ;将bx内的值加1,这里是偏移到后一个数据内存地址处
    42 0000003A E2F7                        loop digist ;在cx为0前会一直跳转到digist处执行,每次执行减1
    43                                  
    44                                      ;开始显示各个数位
    45 0000003C BB[5300]                    mov bx,number
    46 0000003F BE0400                      mov si,4
    47                                  show:
    48 00000042 8A00                        mov al,[bx+si] ;将number的最后一个地址的内容
    49 00000044 0430                        add al,0x30
    50 00000046 B404                        mov ah,0x04 ;设置颜色编码
    51                                      ;由于前面设置的是正向从低到高地址传输,故ax低字节存字符,高字节存颜色
    52 00000048 268905                      mov [es:di],ax
    53 0000004B 83C702                      add di,2 ;加2以指向下一个显存的位置
    54 0000004E 4E                          dec si ;让下一次bx+si指向前一个存储数位的地址
    55 0000004F 79F1                        jns show
    56                                  
    57 00000051 EBFE                        jmp $ ;表示重复跳转到自身
    58                                  
    59 00000053 0000000000              number db 0,0,0,0,0
    60                                  
    61 00000058 00<rep 1A6h>                times 510-($-$$) db 0 ;$表示这一行的汇编地址 $$表示当前程序段的地址,这里是jmp第一行的开头的汇编地址
    62                                  
    63 000001FE 55AA                        db 0x55,0xaa
